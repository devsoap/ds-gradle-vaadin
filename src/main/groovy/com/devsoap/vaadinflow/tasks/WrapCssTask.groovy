/*
 * Copyright 2018-2020 Devsoap Inc.
 *
 * Licensed under the Creative Commons Attribution-NoDerivatives 4.0
 * International Public License (the "License"); you may not use this file
 * except in compliance with the License.
 *
 * You may obtain a copy of the License at
 *
 *      https://creativecommons.org/licenses/by-nd/4.0/
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.devsoap.vaadinflow.tasks

import com.devsoap.vaadinflow.actions.JavaPluginAction
import com.devsoap.vaadinflow.extensions.VaadinFlowPluginExtension
import com.devsoap.vaadinflow.util.ClassIntrospectionUtils
import groovy.util.logging.Log
import io.github.classgraph.Resource
import io.github.classgraph.ScanResult
import org.gradle.api.DefaultTask
import org.gradle.api.GradleException
import org.gradle.api.file.FileTree
import org.gradle.api.tasks.CacheableTask
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction

import java.nio.file.Paths

/**
 * Generates corresponding HTML/JS files for CSS files located in frontend/styles
 *
 * @author John Ahlroos
 * @since 1.0
 */
@Log('LOGGER')
@CacheableTask
class WrapCssTask extends DefaultTask {

    static final String NAME = 'vaadinWrapCss'

    static final String STYLES_TARGET_PATH = 'webapp-gen/frontend/styles'
    static final String CSS_REGEXP = '**/*.css'

    private static final String CSS = CSS_EXTENSION
    private static final String FRONTEND = 'frontend'
    private static final String STYLES = 'styles'
    public static final String CSS_EXTENSION = '.css'
    public static final String META_INF_RESOURCES = 'META-INF/resources/'

    @Optional
    @InputDirectory
    @PathSensitive(PathSensitivity.ABSOLUTE)
    final Closure<File> cssSourceDir = {
        AssembleClientDependenciesTask assembleTask = project.tasks.findByName(AssembleClientDependenciesTask.NAME)
        VaadinFlowPluginExtension vaadin = project.extensions.getByType(VaadinFlowPluginExtension)
        File dir = vaadin.compatibilityMode ?
            Paths.get(assembleTask.webappDir.canonicalPath, FRONTEND, STYLES).toFile() :
            Paths.get(project.projectDir.canonicalPath, JavaPluginAction.STYLESHEETS_SOURCES.split('/')).toFile()
        dir.exists() ? dir : null
    }

    @Optional
    @InputFiles
    @PathSensitive(PathSensitivity.ABSOLUTE)
    final Closure<FileTree> cssFiles = {
        File stylesPath = cssSourceDir.call()
        if (stylesPath && stylesPath.exists()) {
            return project.fileTree(stylesPath).matching { it.include(CSS_REGEXP) }
        }
        null
    }

    @Optional
    @InputFiles
    @PathSensitive(PathSensitivity.ABSOLUTE)
    final Closure<FileTree> sassCssFiles = {
        File stylesPath = Paths.get(project.buildDir.canonicalPath, 'jsass').toFile()
        stylesPath.exists() ? project.fileTree(stylesPath).matching { it.include(CSS_REGEXP) } : null
    }

    @OutputDirectory
    final Closure<File> targetPath = {
        VaadinFlowPluginExtension vaadin = project.extensions.getByType(VaadinFlowPluginExtension)
        vaadin.compatibilityMode ?
            new File(project.buildDir, STYLES_TARGET_PATH) :
            Paths.get(project.buildDir.canonicalPath, 'frontend', 'src').toFile()
    }

    WrapCssTask() {
        group = 'vaadin'
        description = 'Wraps CSS files in HTML/JS wrappers'
        dependsOn('classes')
    }

    @TaskAction
    void run() {
        VaadinFlowPluginExtension vaadin = project.extensions.getByType(VaadinFlowPluginExtension)
        if (vaadin.compatibilityMode) {
            if (cssFiles.call()) {
                convertToHtml(cssFiles.call())
            }

            if (sassCssFiles.call()) {
                convertToHtml(sassCssFiles.call())
            }
        } else {
            convertToJs()
        }
    }

    @Deprecated
    private void convertToHtml(FileTree tree) {
        tree.each {
            LOGGER.info("Wrapping $it in HTML wrapper")
            String content = """
            <!-- This is a autogenerated html file for ${it.name}. Do not edit this file, it will be overwritten. -->
            <custom-style><style>
            """.stripIndent()

            content += it.text

            content += '\n</style></custom-style>'

            new File(targetPath.call(), "${ it.name - CSS}.html" ).text = content
        }
    }

    private void convertToJs() {

        // Find @CssImport annotations
        VaadinFlowPluginExtension vaadin = project.extensions.getByType(VaadinFlowPluginExtension)
        ScanResult scan = ClassIntrospectionUtils.getAnnotationScan(project)
        Map<String,Map<String,String>> cssImports = ClassIntrospectionUtils.findCssImports(vaadin, scan)
        Map<String, String> cssResources = ClassIntrospectionUtils.findCssInResources(project, cssImports.keySet())

        // Generate Css Javascript wrappers for each import
        cssImports.each { path, annotation ->
            File cssFile = new File(cssSourceDir.call(), path)
            if (cssFile.exists()) {

                // CSS is located in the project
                LOGGER.info("Wrapping $cssFile in JS wrapper")

                // Read content from CSS file and put it in a JS Wrapper
                String content = writeAutogeneratedComment(cssFile.name)
                if (annotation.isEmpty()) {
                    content += writeNoValueTemplate(cssFile.name, cssFile.text)
                } else if (annotation?.target || annotation?.id) {
                    content += writeTargetOrIdValueTemplate(cssFile.name, cssFile.text, annotation)
                } else {
                    content += writeAllValuesTemplate(cssFile.name, cssFile.text, annotation)
                }
                content += writeDocumentAppend()

                // Write wrapped JS into file system
                File js = new File(targetPath.call(), "${ cssSourceDir.call().relativePath(cssFile) - CSS }.js" )
                js.parentFile.mkdirs()
                js.text = content

            } else if (cssResources.containsKey(path) || cssResources.containsKey(META_INF_RESOURCES + path)) {

                // CSS is located in the classpath
                LOGGER.info("Wrapping classpath CSS file $path in JS wrapper")
                String cssResource = cssResources[path] ?: cssResources[META_INF_RESOURCES + path]

                // Read content from CSS file and put it in a JS Wrapper
                String content = writeAutogeneratedComment(path)
                if (annotation.isEmpty()) {
                    content += writeNoValueTemplate(path, cssResource)
                } else if (annotation?.target || annotation?.id) {
                    content += writeTargetOrIdValueTemplate(path, cssResource, annotation)
                } else {
                    content += writeAllValuesTemplate(path, cssResource, annotation)
                }
                content += writeDocumentAppend()

                // Write wrapped JS into file system
                File js = new File(targetPath.call(), "${ path - CSS - META_INF_RESOURCES }.js" )
                js.parentFile.mkdirs()
                js.text = content

            } else {
                // CSS file not found
                LOGGER.warning("The file path ($path or ${ "META-INF/resources/$path" }) the @CssImport value points " +
                        'to does not exist. Import ignored.')
            }
        }
    }

    private static String writeNoValueTemplate(String name, String css) {
        """
        const \$_documentContainer = document.createElement('custom-style');
        \$_documentContainer.setAttribute("id", "wrapped-${name - CSS_EXTENSION}");
        \$_documentContainer.innerHTML = `<style>
        $css
        </style>`;
        """.stripIndent()
    }

    private static String writeTargetOrIdValueTemplate(String name, String css, Map<String,String> values) {
        """
        const \$_documentContainer = document.createElement('dom-module');
        ${values.id ? "\$_documentContainer.setAttribute(\"id\",\"${values.id}\");" : '' }
        ${values.target ? "\$_documentContainer.setAttribute(\"theme-for\",\"${values.target}\");" : '' }
        \$_documentContainer.innerHTML = `<template id="wrapped-${name - CSS_EXTENSION}">
        <style ${values.include ? "include=\"${values.include}\"" : ''}>
        $css
        </style>
        </template>`;
        """.stripIndent()
    }

    private static String writeAllValuesTemplate(String name, String css, Map<String,String> values) {
        """
        const \$_documentContainer = document.createElement('custom-style');
        \$_documentContainer.setAttribute("id", "wrapped-${name - CSS_EXTENSION}");
        \$_documentContainer.innerHTML = `
        <style ${values.include ? "include=\"${ values.include }\"" : ''}>
        $css
        </style>`;
        """.stripIndent()
    }

    private static String writeAutogeneratedComment(String name) {
        """
        // This is a autogenerated Javascript file for ${name}. Do not edit this file, it will be overwritten.
        """.stripIndent()
    }

    private static String writeDocumentAppend() {
        """
        document.head.appendChild(\$_documentContainer);
        """.stripIndent()
    }
}
